"""
This implements the command dispatch module as described in DeadDrop's
generic architecture model for agents.

If any additional operations are needed before handing the message off to
a particular command, it should be done here. This may include adding
command-specific arguments that are not already present in the configuration
object, and therefore must be handled on a case-by-case basis.

The spirit of this design is that any edge case handling can be centralized
to this module, allowing the command to remain (relatively) loosely bound
from the rest of Pygin's libraries.
"""

from typing import Any, Type
import traceback

from pydantic import BaseModel

# Make all commands visible. This is an intentional star-import so that
# our helper functions work. Nothing from this module is actually used directly.
from src.commands import *  # noqa: F403, F401
from deaddrop_meta.command_lib import get_commands_as_dict


def execute_command(cmd_name: str, args: dict[str, Any]) -> dict[str, Any]:
    """
    Execute a command by name.

    It is assumed that the arguments for this command are directly from the
    `payload` field of the `command_request` message; they do not have to be
    parsed, as this will be handled by an explicit call to ArgumentParser.

    :param cmd_name: The name of the command to invoke.
    :param args: The arguments to pass to the command.
    :returns: A dictionary result generated by the command.
    """
    # Discover the relevant command class by lookup.
    try:
        cmd_class = get_commands_as_dict()[cmd_name]
    except KeyError:
        raise RuntimeError(f"Command {cmd_name} isn't registered!")

    # Invoke the model. If it passes validation, that means that the required
    # arguments are present and that they're all of the correct type. Else,
    # this raises ValidationError and execution stops here.
    #
    # mypy complains about properties as usual
    arg_model: Type[BaseModel] = cmd_class.argument_model  # type: ignore[assignment]
    validated_args = arg_model.model_validate(args)

    # Actually execute the command and return its immediate result.
    try:
        return cmd_class.execute_command(validated_args.model_dump())
    except Exception:
        # On failure, return a message describing the uncaught error;
        # normally, commands have their own error handling
        return {"error": traceback.format_exc()}

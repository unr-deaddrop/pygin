"""
Base definitions for protocols and the DeadDrop standard message format.

TODO: In the distant future, this should be its own library. It is being included
with the Pygin distribution since we currently don't *have* another agent type.
Important to note is that this being its own library doesn't need to happen
for the server to work, since everything should be exported as a JSON by any
agent anyways.

This library must not import any other internal libraries; it may only import
the standard library and external packages.

Each protocol is implemented as a subclass of ProtocolBase, an abstract class
containing several properties that may (or may not) be defined.

The available protocols for a particular agent are determined by inspecting all
available subclasses of ProtocolBase.

When a protocol depends on some external library or binary, it is assumed to be
managed *outside* of the Python environment; that is, it does not need to be
installed as part of the normal Python environment setup process, and can be
handled by an initial setup script at the OS level.
"""

from datetime import datetime
from enum import Enum
from typing import Any, Type
import abc
import uuid
import json

from pydantic import BaseModel, Field


class DeadDropMessageType(str, Enum):
    """
    String enumeration of all available message types.
    """

    # Message generated in response to a command. Messages of this type are only
    # ever generated by agents.
    CMD_RESPONSE = "command_response"

    # Message generated as a request for an agent to execute a command. Messages
    # of this type are only ever generated by agents.
    CMD_REQUEST = "command_request"

    # One or more log entries generated by an agent. One "log message" may contain
    # multiple log entries, as the "payload" field may
    LOG_MESSAGE = "log_message"

    # Heartbeat message generated by an agent. May contain additional diagnostic
    # data.
    HEARTBEAT = "heartbeat"

    # Heartbeat
    INIT_MESSAGE = "init_message"


class DeadDropMessage(BaseModel, abc.ABC):
    """
    Class representing the basic definition of a DeadDrop message.

    All messages contain the following information:
    - One of five standard message types (dictated by DeadDropMessageType).
    - The server-side user ID associated with the message, if any, for
      accountability purposes.
    - The ID of the agent where the message originated from. If the message
      is forwarded, this contains the ID of the original agent that constructed
      this message. If the message originates from the server, this is empty.
    - The ID of the message, a UUID.
    - The timestamp of the message.
    - The digest of the message, intended to be a digital signature. The agent
      stores its own private key and the public key of the server; the server
      stores its own private key and the public key of the agent. It is important
      to note that the agent's private key is not protected from discovery; it is
      therefore possible to forge valid messages originating from a particular agent.
      This weakness is outside the intended scope of this project.
    - A "payload" field, which contains the actual payload of the message. The
      payload is another JSON dictionary that varies in sturcture depending on
      the message type. Generally, the payload is considered

    Note that the encryption or fragmentation of messages is delegated to protocols.
    It is best to think of the standard messaging system as the application layer,
    and the covert communication protocols as the transport layer.

    In the future, these messages may be wrapped in another JSON object containing
    forwarding information, effectively allowing it to be routed (as if it were
    at the networking layer). This is not planned in the short term.

    FIXME: This belongs in an external lib, not Pygin.
    """

    # The underlying message type.
    message_type: DeadDropMessageType

    # The UUID of the message. If not set at construct time, it is set
    # to a random value (i.e. uuidv4).
    message_id: uuid.UUID = Field(default_factory=uuid.uuid4)

    # The user this message is associated with. May be empty (such as with logs
    # that are not tied to a user).
    user_id: uuid.UUID

    # The agent or server ID.
    source_id: uuid.UUID

    # The timestamp that this message was created.
    timestamp: datetime = Field(default_factory=datetime.utcnow)

    # Underlying message data. Notice that this is always stored as `str`.
    # This is for a variety of reasons, namely the fact that JSON does not support
    # arbitrary binary data.
    payload: str | None = None

    # Digital signature as a string.
    digest: str | None = None


class ProtocolBase(abc.ABC):
    """
    Abstract base class representing the standard definition of a protocol
    for Python-based agents.
    """

    @property
    @abc.abstractmethod
    def name(self) -> str:
        """
        The internal protocol name displayed to users and used in internal
        messaging.

        It is preferred that this is a valid Python variable name for future
        compatibility.
        """
        pass

    @property
    @abc.abstractmethod
    def version(self) -> str:
        """
        The version string for this protocol implementation.
        """
        pass

    @property
    @abc.abstractmethod
    def description(self) -> str:
        """
        A brief description of this protocol, to be displayed to users (primarily)
        through the web interface.
        """
        pass

    @abc.abstractmethod
    def send_msg(self, msg: bytes, **kwargs) -> bytes:
        """
        Send an arbitrary binary message.

        This function should implement any mechanisms needed to split messages,
        place messages at an agreed-upon location, and so on. If any additional
        paramters are required for this to function, such as the credentials
        needed to access the account used for transferring information, they
        may be passed as protocol-specific keyword arguments.

        This function may raise exceptions.

        The return value of this function is always bytes, but the underlying
        structure may be anything; it is up to the agent core to decide how to
        handle the responses of a particular protocol implementation.

        :param msg: The binary message to send.
        """
        # TODO: does this actually work with Celery tasking?
        pass

    @abc.abstractmethod
    def check_for_msg(self, **kwargs) -> bytes:
        """
        Retrieve the least recent message that has yet to be retrieved.

        Each time this message is called, either an empty bytestring is returned,
        or the next available message is retrieved. The process of reconstructing
        messages, if needed, is handled opaquely.

        If additional arguments are required for this to operate, such as the
        credentials needed to log onto an account or a shared meeting, they
        may be passed as keyword arguments.

        This function may raise exceptions, such as if a service is inaccessible.
        """
        # TODO: does this actually work with Celery tasking?
        pass

    def to_dict(self) -> dict[str, Any]:
        """
        Return this protocol's metadata as a dictionary.
        
        Note that for compatibility purposes, ensure that the resulting dictionary
        is completely JSON serializable.
        """
        return {
            "name": self.name,
            "description": self.description,
            "version": self.version,
        }


def export_all_protocols() -> list[Type[ProtocolBase]]:
    """
    Return a list of visible protocol classes.

    The protocol lookup occurs by inspecting all available subclasses of ProtocolBase
    when this function is executed.

    Note that "visible" means that the associated subclasses of ProtocolBase must
    already have been imported. If you implement a script to generate the command JSONs,
    you will need to import the commands ahead of time.
    """
    return ProtocolBase.__subclasses__()


def get_protocols_as_dict() -> dict[str, Type[ProtocolBase]]:
    """
    Return a dictionary of commands, suitable for lookup.

    The keys are the `name` attribute of each command found; the values are the
    literal types for each command (a subclass of CommandBase).
    """
    # mypy doesn't handle properties well; this works in practice, and the type
    # of cmd.name is *always* str
    return {proto.name: proto for proto in export_all_protocols()}  # type: ignore[misc]


def export_protocols_as_json(protocol_classes: list[Type[ProtocolBase]], **kwargs):
    """
    Return a nicely formatted string containing all command information,
    suitable for presentation in the DeadDrop interface.
    """
    json_objs: list[dict[str, Any]] = []
    for command_class in protocol_classes:
        json_objs.append(command_class().to_dict())

    return json.dumps(json_objs, **kwargs)

"""
Main script that accepts a path to a configuration file and writes agent.cfg
according to it. If desired, a public and private key are also generated and
returned as part of the JSON result object.

Configuration files are expected to have two top-level keys as shown below:
```json
{
    "agent_config":{
        ...
    },
    "protocol_config":{
        ...
    }
}
```

`agent_config` should contain the keys that are specific to the agent's 
configuration. These are the keys exported by `agent.cfg`.

`protocol_config` should contain one key, equal in value to the `section_name`
attribute of the corresponding `ProtocolBase` class, whose value is a dictionary
of arguments supported by that protocol's corresponding `ProtocolConfig` class.

For example, if we wanted configuration for plaintext_local and Pygin, we'd
do something like
```json
{
    "agent_config":{
        "AGENT_ID" : "00000000...",
        ...
    },
    "protocol_config":{
        "plaintext_local":{
            "PLAINTEXT_LOCAL_CHECKIN_FREQUENCY": 10,
            "PLAINTEXT_LOCAL_INBOX_DIR": "./msgs/inbox"
            "PLAINTEXT_LOCAL_OUTBOX_DIR": "./msgs/outbox"
        }
    }
}
```

This script also performs some light validation, namely those provided by
Pydantic when the associated models for protocol configurations and agent
configuration are instantiated. Should any fail, the build is assumed to have
failed. Similar checks are performed to make sure that the specified
config keys and protocols actually exist.
"""

from pathlib import Path
import argparse
import json
import logging
import os
import sys

from Cryptodome.PublicKey import ECC
from src.agent_code.config import PyginConfig

# Logs are written to payload-logs.txt as per convention. There is no convention 
# for the log file itself, since this all becomes one giant Log entry anyways.
logging.basicConfig(
    handlers=[
        logging.FileHandler("payload-logs.txt", mode="a", encoding="utf-8"),
        logging.StreamHandler(sys.stdout),
    ],
    level=logging.DEBUG,
    format="%(filename)s:%(lineno)d | %(asctime)s | [%(levelname)s] - %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)
# TODO: https://stackoverflow.com/questions/6234405/logging-uncaught-exceptions-in-python

# The default "input" JSON path. This is a user-supplied JSON file that contains
# the "initial" configuration for the payload, which is validated and filled in 
# as needed.
DEFAULT_JSON_PATH = Path("./build_config.json")

def process_config_file(json_path: Path) -> PyginConfig:
    """
    Process a configuration JSON5 file, generating a PyginConfig from it.
    
    When a field is required and no value has been provided, a random value
    is generated by default according to the field's default factory by
    Pydantic.
    """
    # Begin by attempting to verify the configuration file as-is. If no exception
    # is raised, the initial build parameters are good.
    with open(json_path, "rt") as fp:
        cfg_obj = PyginConfig.from_json5_file(json_path)
    
    # Pygin uses AES-128-CBC and ECDSA for encryption. In turn, a 128-bit key
    # and a new ECC keypair is generated. Consistent with the server, the Ed25519
    # curve is used for key generation and verification.
    encryption_key = os.urandom(16)
    
    # The same parameters as in Pycryptodome's documentation are used to export the 
    # keypair. The private key is not password-protected, since we'd need to store
    # that somewhere anyways and therefore the key can be stolen either way.
    agent_key = ECC.generate(curve='ed25519')
    private_key = agent_key.export_key(format='PEM')
    public_key = agent_key.public_key().export_key(format='PEM')
    
    # These values are now applied to PyginConfig. Note that if the server has
    # neglected to include its own public key, the agent will not perform
    # signature verification.
    cfg_obj.ENCRYPTION_KEY = encryption_key
    cfg_obj.AGENT_PRIVATE_KEY = private_key
    cfg_obj.AGENT_PUBLIC_KEY = public_key
    
    # The result is returned as-is.
    return cfg_obj

def get_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="The Pygin main process.")

    # Access this argument as cfg_path.
    parser.add_argument(
        "--cfg",
        "-c",
        default=DEFAULT_JSON_PATH,
        type=Path,
        help="The configuration variables to start with.",
        required=False,
        dest="cfg_path",
    )

    return parser.parse_args()

if __name__ == "__main__":
    args = get_args()
    json_path = Path(args.cfg_path).resolve()
    
    # Assert that our JSON5 file is there
    if not json_path.exists():
        raise RuntimeError(f"{json_path} is missing, cannot continue")
    
    # Process the configuration file to generate a fully valid PyginConfig
    # model, as well as any nested models contained in the JSON file. 
    # 
    # Note that the agent configuration file is generated *as-is*; that is, if
    # Pygin is set up to listen on a particular port, it is the responsibility
    # of the server (or its relevant protocol handler) to interpret this as
    # the *agent's* configuration, not the server's configuration. In turn,
    # the server should not send on the same port that the agent is sending on,
    # but instead on the port that the agent is listening on. This is part of
    # the functionality provided by mini_server.py.
    cfg_obj = process_config_file(json_path)
    
    # Write the final PyginConfig instance back to disk. This is the configuration
    # that the agent will use (take care that you're not overwriting it in a real
    # repository!)
    with open('agent_cfg.json', "wt") as fp:
        fp.write(cfg_obj.model_dump_json(indent=2))